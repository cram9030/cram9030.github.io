---
layout: default
title: "Is Asking an LLM Worth The Time?"
date: 2025-01-19
---

Like everyone else over the past few years I've been playing around with some of the more prolific Large Language Models(LLM) trying to work them into a general workflow to figure out what works the best for me. Some of it is figuring out useful prompts but a lot of it is figuring out what other existing tools are just faster. I remember the XKCD comic below of the "Is It Worth The Time?" chart which sort of inspired me to try and set up a running comparison of things that were not worth the time.

<div style="text-align: center;">
    <img src="https://imgs.xkcd.com/comics/is_it_worth_the_time.png" alt="XKCD Time Management Chart">
</div>

Most of the issues I've observed are fall into a few different categories, listed in no particular order.

1. Exploritory question turns into implementation request which provides an overly complicated solution
2. To large of a chunk of work requested
3. Troubleshooting results in overly complicated implementations
4. API (Application Programming Interface) related questions

In a lot of ways the LLMs having issues with these sort of request makes a lot of sense. The first one centers around not having enough initial information to articulate what we want to do in detail essentially a task that lacks clear existing requirements. This is one of the hardest things because coming up with what we want is a lot harder than saying what we don't want. This has spawned numerous humerous cartoons, youtube videos, and fully fledge industries. 

The second issue essentially comes down to another common problem which is breaking down work into its smallest chunks to start executing from. The larger the scope the harder it is to find a starting point. The combination of the first and second problems are some of the primary motivating factors for Agile Development where accepting that we don't have a good idea of the requirements means we should create something to help determine the actual needs as quickly as possible and focusing on small time and task decomposition forces smaller tasks and better execution.

The third and forth issues would seem to stem not from a fundamental complication with development itself but from the source training material. While there is a lot of content online with simple examples it is usually through the examples of how to use the library provided. If those examples were working and sufficent though there would not really need to be any troubleshooting. More often what ends up happening is we start deviating from those examples and when we start troubleshooting that might warrent a more complicated solution because the simple one was already dispositioned by the initial documentation. Some prominent exceptions are "it works on my machine" or environment setup issues, linking issues, or concepts that are so "fundamental" they don't get covered in examples.

The APIs are challenging well because the reasons they are challenging are pretty unique and often have single sources of truth that work off a combination of inputs. An example of this is that I was trying to use MoveIt in a python development environment. A quick googling made me think that [moveit_py](https://github.com/moveit/moveit2/blob/main/moveit_py/README.md) seemed like a greate choice there were some examples that I wanted to adapt so I asked Claude to adapt them but it never really worked. It kept mixing API called between different versions of MoveIt that weren't the current version I was trying to use. Then after all of it I was able to determine the core issue was [ROS Humble was just not going to support those features](https://moveit.ai/moveit%202/ros/2023/05/31/balancing-stability-and-development.html). So it was an API problem where it assumed what the API should be based on the API through the rest of the library instead of *knowing* what the API actually was. On top of that there was that pesky version, environment, and support issue which funnily enough did warrent the more complicated solution though the real answer was to just use the API that called the C++ version of the code that was supported in the environment. 

In any case I'm going to keep a running table of things that did actually save me time and I might update the prose above as I develop and learn more. All the contents of this table was done with Claude and I have not attempted to recreate it with any of the other prominant LLMs.

| Task | Result | Time Saved? | Commentary |
|------------------|--------|-------|------------|
| Making a this personal website | <span class="cell-yellow">⚠️ Mixed</span> | <span class="cell-yellow">Little</span> |The fact that this was not really a net time saver was a little suprising. It started out well with the initial suggestion to use github pages and jekyll was good and the first website suggestions worked pretty well. The time that was gained with the intial spin up was pretty quickly lost when it started suggesting customized github actions that the core functionality already existed through the pages deployment. I ended up having to go read the github pages and Jekyll documentation anyway to be able to correct my issues. <br><br> I spent probably a solid afternoon maybe 4 or 5 hrs playing around and getting things working. I was starting from zero and I thought with Claude I would half that time. If I had just spent the first hour going through the examples on github pages I probably would have taken roughly the same amount of time.|
| Making this table| <span class="cell-green">✅ Good</span> | <span class="cell-green">Realtively Lage</span> | A single prompt got this working and a quick googling suggests I would have probably struggled trying to make this work in markdown before realizing I really needed to update the css. It wasn't a lot of absolute time but relative to the task it was a significant proportion|
| Embedding React Visualization| <span class="cell-green">✅ Good</span> |  <span class="cell-green">Realtively Lage</span> | In my first blog post I was showing my quick visualization that I had created just to help get some face validity on what I wanted to do. I woudn't have really known where to start but the solution worked off the first prompt and the only follow ups were asking for it in a seperate artifact.|
| Resolving Import Errors | <span class="cell-yellow">⚠️ Nuetral </span> | <span class="cell-yellow">No Gain</span> | Honestly just writting out the problem to put in the prompt had a bigger impact on my solving the issue than the response did.|
| Docker Copy/Pathing Issues | <span class="cell-red">❌ Bad </span> | <span class="cell-red">Time Lost </span> | I've tried this a few times in a few different ways. This is one of the more frusturating things to deal with when trying to put together your project structure and test environments. There are a lot of best practices that are unique to the goal and the hope would be that using an LLM could help transfer those over but it's been pretty bad and I have always had to end up going back to the source documentation and other posts to actually solve my issues. More often than not I just end up using Claude to create a consistent docker-compose or dockerfile after I've already figured out the best way after spending time removing the intial proposal from my first prompt.|
| Binary Lookup Table Storage for DLLs| <span class="cell-green">✅ Good</span> | <span class="cell-yellow">No Gain</span> |There wasn't really a time gain here because I would have implemented a solution just as fast without the feedback but the solution proposed was a good one (basically what I had been planning to do just simply static array ```static constexpr std::array<std::pair<float,float>, 7>```) so if I hadn't already known what I wanted it would have saved time for maybe a student.|
| Almost anything with ROS2| <span class="cell-red">❌ Bad </span> | <span class="cell-red">Time Lost </span> | I should start by saying I've used ROS2 before a few times. I'm not what I would consider an expert but a functional user. Ideally that seemed like the level that I could give good enough prompts that were contained enough to get effecive answers to be used when developing. That is not how it turned out. I spent a lot more time reading, troubleshooting, checking, and trying to understand the proposed solutions. A good chunk of this could have been user error but they were always over complicated solutions that didn't really leverage ROS2 as a development platform almost always opting to create things from scratch when there was existing messages that could achieve the objectives for examples. I don't know when I will try this again but I am pretty sure just starting from an existing ROS2 example and editing would have saved me a significant amount of time instead of asking Claude to start from the same example and update it to my needs.<br><br>The one advantage that I did note was it put in a lot more good quality checks into my code than I would have put in naturally that this stage of development. They were almost always correct and probably would have been things I went back to do once the core logic was working but they got implemented earlier with little to no additional effort on my part.|
|Simplifying Existing ROS2 Node| <span class="cell-green">✅ Good</span> |  <span class="cell-green">Meaningful Gain</span> |The one exception to the row above was when I already had a node that I wanted to keep the interface the same and simply update the core business logic. In that case I provided the drawings, the equations I wanted implemented, and the existing code with the features I needed and it was able to pump out something that functioned as intended and with minor followups get it executing in the framework I wanted.|
|Writting git commit messages| <span class="cell-green">✅ Good</span> | <span class="cell-yellow">No Gain</span> |The commits were a lot better quality than I would have written myself. I've done the same thing with Co-Pilot and it was good as well though Claudes were a little more comprehensive. Co-pilot being embedded into VS Code makes it significantly more convienent.|
|Implementing Complex Equations| <span class="cell-red">❌ Bad </span> | <span class="cell-red">Time Lost </span> |I had thought with the simplifying existing ROS2 example above I had cracked the code and that as long as I wrote out the math (something I almost always start with anyway before I go to code) that I'd be able to crank out full classes just by copying an pasting. After all all it have to do was move either Latex or the print output of SymPy into a function. Well it really did not want to when I gave it a big long equation with a bunch of states and decimals. Two of the equations could have one of the constants pulled out and multiplied after the fact with out being passes into the function itself but the other four couldn't instead of just passing the values into the functions for the other four equations what it instead opted to do was just remove the parts of the equations prevented that from happening so it could be consistent between all the functions format! They were pretty long nonlinear equations with something around 30 unique coffiecent/variable combinations so having to go line by line to confirm what was and wasn't loss was incredibly tedious.<br><br>This is a case where what I should have done is just let it write the interface and populated the equations myself. I already had a version I could copy and past from the output of SymPy which I would just need to match the parameters.|